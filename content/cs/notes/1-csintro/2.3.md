---
title: 2.3 计算机中的二进制四则运算
---

## 无符号整数与加法

### 无符号整数 (Unsigned Integers)

- **定义**：最简单的二进制表示，只能表示非负整数（0, 1, 2, ...）。
- **类比**：就像汽车的里程表，只能正向增加。
- **表示范围**：$n$ 位二进制数能表示 $2^n$ 个不同的数。
  - 8 位 (1 字节)：$0 \sim 255$ ($2^8 - 1$)
  - 16 位：$0 \sim 65535$
  - 32 位：$0 \sim 42$ 亿左右

### 二进制加法

- **规则**：和十进制加法一样，从右向左算，只是“逢二进一”。
  - $1 + 1 = 10$ (写 0 进 1)
  - $1 + 1 + 1 = 11$ (写 1 进 1)

{{< callout >}}

**示例** 计算 $5+3$ (4 位二进制)

$$
\begin{array}{rl}
0101 & (5) \\ +
0011 & (3) \\ \hline
1000 & (8)
\end{array}
$$

{{</ callout >}}

**过程解析**：

1. 最低位：$1+1=10$，写 0 进 1。
2. 次低位：$0+1+1(\text{进位})=10$，写 0 进 1。
3. 第三位：$1+0+1(\text{进位})=10$，写 0 进 1。
4. 最高位：$0+0+1(\text{进位})=1$。

- **溢出 (Overflow)**：
  - 如果结果超过了位数能表示的最大值，最高位的进位会被丢弃，导致结果错误。
  - 就像 8 位里程表从 `99999999` 再跑 1 公里变成 `00000000`。

## 乘法与除法

### 二进制乘法

- **原理**：类似于十进制乘法，但更简单，因为乘数只有 0 或 1。
  - 如果乘数位是 1，就把被乘数抄下来（移位）。
  - 如果乘数位是 0，就全是 0。
  - 最后把所有结果加起来。

{{< callout >}}

**示例** $5\times3$

$$
\begin{array}{rl}
0101 & (5) \\ \times
0011 & (3) \\ \hline
0101 & (\text{乘以最低位的1}) \\
0101 \phantom{0} & (\text{乘以次低位的1，左移一位}) \\ +
0000 \phantom{0}\phantom{0} & (\text{乘以第三位的0，左移两位}) \\ \hline
001111 & (15)
\end{array}
$$

{{</ callout >}}

### 二进制除法

- **原理**：类似于十进制长除法，通过“移位”和“相减”实现。
- 计算机硬件通常使用重复减法等算法来实现，比加法复杂得多。

## 带符号整数的减法与补码

### 为什么要用补码？

在计算机中，我们希望用同一套电路（加法器）来处理加法和减法。

- **原码 (Sign-Magnitude)**：最高位表示符号（0 为正，1 为负）。
  - 问题 1：0 有两种表示（`+0` 和 `-0`）。
  - 问题 2：加减法复杂，例如 `1 + (-1)` 需要判断绝对值大小。
- **补码 (Two's Complement)**：解决了上述问题，是现代计算机的标准。

### 补码的计算方法

1. **正数**：补码 = 原码（最高位为 0）。
   - 例 (+5)：`0000 0101`
2. **负数**：**取反加一**。
   - 第一步：写出对应正数的二进制。
   - 第二步：按位取反（0 变 1，1 变 0）。
   - 第三步：结果加 1。

{{< callout >}}

**示例**：计算 $-5$ 的 8 位补码

1. 写出 +5：`0000 0101`
2. 按位取反：`1111 1010`
3. 末位加 1：`1111 1011`

   所以，-5 在计算机中存储为 `1111 1011`。

{{</ callout >}}

### 考场技巧：快速求补码

在笔算时，取反加一容易出错（特别是进位）。可以使用**从右往左找第一个 1**的技巧：

1. **从右向左**扫描二进制数。
2. 找到**第一个 1**。
3. **这个 1 和它右边的所有 0** 保持不变。
4. **这个 1 左边的所有位** 全部取反。

{{< callout >}}

**示例**：快速求 $-20$ 的 8 位补码

1. $20$ 的原码：`0001 0100`
2. 从右往左找第一个 1：`... 1 00`
3. 保持不变部分：`_ _ _ _ _ 1 00`
4. 左边取反：`1 1 1 0 1 1 00`

结果：`1110 1100`。

{{</ callout >}}

### 补码减法运算

计算机不直接做减法，而是把减法转化为加法：$A - B = A + (-B)$。

{{< callout >}}

**示例** $5-3$

1. 转化为：$5 + (-3)$
2. 5 的补码：`0000 0101`
3. -3 的补码：(3=`0000 0011` $\rightarrow$ 取反`1111 1100` $\rightarrow$ 加 1) `1111 1101`
4. 相加：

   $$
   \begin{array}{rl}
   00000101 & (5) \\ +
   11111101 & (-3) \\ \hline
   100000010 & (\text{结果为2})
   \end{array}
   $$

5. **注意**：最高位的进位 `1` 被丢弃（因为我们只有 8 位），剩下的 `0000 0010` 正好是 2。

{{</ callout >}}

### 溢出判断

在补码运算中，如果两个正数相加得到负数，或两个负数相加得到正数，说明发生了**溢出**。

## 浮点数 (Floating Point Numbers)

### 核心思想：科学计数法

就像十进制中我们可以把很大的数写成 $1.23 \times 10^4$ 一样，二进制数也可以写成科学计数法形式：
$$ \pm 1.xxxxx \times 2^{yyyy} $$
IEEE 754 标准就是规定了如何把这个公式里的三个部分（符号、尾数、指数）塞进 32 位或 64 位空间里。

### IEEE 754 的三个组成部分

以 32 位单精度浮点数为例：

1. **符号位 (Sign, S)** [1 位]

   - `0` 表示正数，`1` 表示负数。

2. **阶码 (Exponent, E)** [8 位] - **决定范围**

   - 存储的是 **指数 + 偏移量 (Bias)**。
   - **为什么要偏移？** 指数可能是负的（比如 $2^{-3}$ 表示很小的数）。为了避免在阶码里再用符号位，标准规定加上一个偏移量（单精度是 127）。
   - 实际指数 = 阶码值 - 127。

3. **尾数 (Mantissa/Significand, M)** [23 位] - **决定精度**
   - 对应科学计数法中的小数部分。
   - **隐藏的 1**：在二进制科学计数法中，规范化后的数字总是 $1.xxxxx$ 的形式（因为最高位不可能是 0，否则就继续移位了）。为了节省空间，这个开头的 `1` **不存储**，默认存在。

### 数值公式

$$ V = (-1)^S \times (1 + \text{尾数小数部分}) \times 2^{(\text{阶码} - 127)} $$

### 举个栗子

假设内存中是：`0 10000010 101000...0`

1. **符号**：0 $\rightarrow$ 正数。
2. **阶码**：`10000010` 是十进制的 130。
   - 真实指数 = $130 - 127 = 3$。
3. **尾数**：`101000...` 表示二进制小数 $.101 = 1 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} = 0.5 + 0.125 = 0.625$。
   - 加上隐藏的 1，底数是 $1.625$。
4. **结果**：$1.625 \times 2^3 = 1.625 \times 8 = 13.0$。

### 常见格式与精度

- **单精度 (float)**：32 位，约 7 位十进制有效数字。
- **双精度 (double)**：64 位，约 15-16 位十进制有效数字。

### 为什么会有误差？

有些小数在二进制里是无限循环的。例如十进制的 `0.1`，在二进制里是 `0.0001100110011...`。
由于尾数位数有限，只能截断，这就产生了**舍入误差**。这也是为什么在编程中 `0.1 + 0.2 != 0.3` 的原因。
