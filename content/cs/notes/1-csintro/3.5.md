---
title: 3.5 函数调用与栈
---

## 函数调用的抽象

函数（过程）是结构化编程的核心。它允许我们将复杂的任务分解为小的、可重用的模块。在高级语言中，调用一个函数（如 `y = sin(x)`）看起来很简单，但在计算机底层，这涉及一系列复杂的协调工作。

### 函数调用的六个步骤

1. **传递参数**：调用者（Caller）将数据（实参）放在被调用者（Callee）能访问的地方。
2. **转移控制**：程序的执行流程从调用者跳转到被调用者。
3. **获得存储空间**：被调用者为自己的局部变量和临时数据分配内存。
4. **执行任务**：执行函数体内的操作。
5. **放置结果**：被调用者将计算结果放在调用者能访问的地方。
6. **返回控制**：被调用者完成任务后，将执行流程交还给调用者，并清理现场。

## 栈 (The Stack)

为了支持函数调用（特别是嵌套调用和递归），计算机使用了一种特殊的数据结构——**栈**。

### 什么是栈？

- **定义**：一块用于存储临时数据的内存区域。
- **特点**：**后进先出 (LIFO, Last In First Out)**。最后放进去的数据，最先被拿出来。
- **类比**：就像洗盘子时叠放的盘子堆。你只能把新盘子放在最上面（Push），也只能从最上面拿走盘子（Pop）。
- **生长方向**：在大多数体系结构（包括 MIPS）中，栈是**向下生长**的（从高地址向低地址扩展）。

### 栈顶指针 SP 与帧指针 FP

为了管理栈帧，CPU 通常使用两个专门的寄存器：

1. **栈顶指针 (Stack Pointer, SP)**：

   - 始终指向当前栈的**最顶部**（最低地址）。
   - **入栈 (Push)**：减小 SP 的值（分配空间），然后写入数据。
   - **出栈 (Pop)**：读取数据，然后增加 SP 的值（释放空间）。

2. **帧指针 (Frame Pointer, FP)**：
   - 指向当前函数栈帧的**固定位置**（通常是栈帧的底部或开始处）。
   - **作用**：在函数执行过程中，SP 可能会因为入栈出栈而变化，而 FP 保持不变。因此，通过 FP 加上偏移量来访问局部变量和参数比用 SP 更稳定、更方便。

## 栈帧 (Stack Frame)

每一次函数调用，都会在栈上分配一段空间，称为**栈帧**（或活动记录 Activation Record）。

### 栈帧里有什么？

一个典型的栈帧包含以下内容：

1. **保存的寄存器**：
   - **返回地址**：函数执行完后该回到哪里？如果函数 A 调用了函数 B，A 必须把自己的返回地址存起来，否则 B 返回时覆盖了返回地址寄存器，A 就回不去了。
   - **保存的参数**：如果参数太多，寄存器放不下，就放在栈里。
   - **其他寄存器**：如果被调用者需要使用某些被约定为“非易失性”的寄存器，它必须先保存旧值，以便返回时恢复。
2. **局部变量**：函数内部定义的、不适合放在寄存器中的变量（如大型数组、结构体）。

{{< callout >}}

**例子** 嵌套调用

假设 `main` 调用 `A`，`A` 调用 `B`。

1. `main` 运行：栈上有 `main` 的栈帧。
2. `main` 调用 `A`：在 `main` 的栈帧下面（低地址）创建 `A` 的栈帧。
3. `A` 调用 `B`：在 `A` 的栈帧下面创建 `B` 的栈帧。
4. `B` 返回：`B` 的栈帧被弹出（销毁），栈顶回到 `A` 的栈帧。

{{</ callout >}}

## 函数调用的实现机制 (以 MIPS 为例)

为了让不同的程序员写的代码能互相调用，大家必须遵守一套规则（约定）。

### 寄存器分工

- **参数传递** (`$a0 - $a3`)：用于传递前 4 个参数。
- **返回值** (`$v0 - $v1`)：用于返回结果。
- **返回地址** (`$ra`)：存储函数调用后的返回地址。
- **栈顶指针** (`$sp`)：始终指向栈顶。
- **帧指针** (`$fp`)：指向当前栈帧的基址。

### 调用过程详解

#### 1. 调用者 (Caller)

- 将参数存入参数寄存器。
- 使用跳转链接指令（如 `jal`）：将下一条指令的地址（PC+4）存入返回地址寄存器 (`$ra`)，然后跳转到目标函数。

#### 2. 被调用者 (Callee)

- **序言 (Prologue)**：
  - 将旧的帧指针 (`$fp`) 入栈保存。
  - 设置新的帧指针：`$fp = $sp`。
  - 调整栈顶指针 (`$sp`)（开辟栈帧空间）。
  - 将返回地址 (`$ra`) 和需要保留的寄存器存入栈中。
- **执行**：
  - 执行函数体的逻辑。
- **尾声 (Epilogue)**：
  - 将结果存入返回值寄存器。
  - 从栈中恢复寄存器旧值和返回地址。
  - 恢复栈顶指针：`$sp = $fp`（销毁栈帧）。
  - 恢复旧的帧指针 (`$fp`)。
  - 跳转回返回地址（如 `jr $ra`）。

## 递归 (Recursion)

栈是实现递归的基础。

- **独立性**：每次递归调用，都会创建一个**新**的栈帧。
- **状态保存**：每个栈帧都有自己独立的参数和局部变量副本，以及独立的返回地址。
- **回溯**：当递归基（Base Case）到达时，开始逐层返回，栈帧逐个弹出，程序能正确地回到上一层调用的位置。

如果没有栈，递归调用会覆盖上一次调用的状态（特别是返回地址和局部变量），导致程序无法正确回溯。
