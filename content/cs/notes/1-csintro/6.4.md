---
title: 6.4 软件中断与系统调用
---

为了保证计算机系统的稳定性和安全性，现代操作系统和 CPU 硬件紧密配合，实施了严格的权限管理机制。

## 内核态与用户态 (以 Intel x86 为例)

CPU 并不是对所有指令都一视同仁的。Intel x86 架构引入了 **特权级 (Privilege Levels)** 的概念，通常被称为 **Rings (保护环)**。

### 保护环 (Protection Rings)

x86 架构定义了 4 个特权级别，从 Ring 0 到 Ring 3：

- **Ring 0 (内核态 / Kernel Mode)**：

  - **权限最高**。
  - 可以执行**所有** CPU 指令（包括特权指令，如修改页表、禁用中断、访问硬件端口）。
  - 可以访问**所有**内存地址。
  - **谁在这里运行？** 操作系统内核（Kernel）的核心代码。

- **Ring 3 (用户态 / User Mode)**：

  - **权限最低**。
  - 只能执行**非特权**指令（如加减乘除、逻辑运算、函数调用）。
  - **不能**直接访问硬件，**不能**直接访问内核内存区域。
  - **谁在这里运行？** 普通应用程序（如浏览器、Word、Python 解释器）。

- _注：Ring 1 和 Ring 2 设计初衷是用于驱动程序等中间层，但在现代主流操作系统（如 Linux, Windows）中通常不使用，只用 Ring 0 和 Ring 3。_

### 为什么要区分？

这种隔离是系统稳定性的基石。如果用户程序（Ring 3）试图执行特权指令（例如直接控制硬盘），CPU 会检测到权限不足，触发一个**硬件异常**，操作系统捕获该异常后通常会直接杀死该进程（比如 Windows 的“蓝屏”往往是内核态出错，而“程序未响应”或崩溃通常是用户态出错）。

## 软件中断与系统调用 (以 Linux 为例)

既然用户态程序不能直接操作硬件（如读写文件、发送网络包），那它们如何完成这些任务呢？答案是：**请求内核代劳**。这个请求的过程就是**系统调用 (System Call)**。

而在早期的 x86 Linux 实现中，实现系统调用的核心机制就是**软件中断**。

### 软件中断机制 (The `int 0x80` instruction)

软件中断是一种由软件指令主动触发的中断，它允许程序从用户态“陷入”到内核态。

以经典的 32 位 Linux 为例：

1. **准备参数**：

   - 应用程序（或 glibc 库）将**系统调用号**放入 `EAX` 寄存器（例如，`exit` 调用的编号是 1，`write` 是 4）。
   - 将参数放入其他通用寄存器（`EBX`, `ECX` 等）。

2. **触发中断**：

   - 程序执行汇编指令 **`int 0x80`**。
   - 这条指令告诉 CPU：“产生第 128 号中断（0x80 是 128 的十六进制）”。

3. **模式切换 (Context Switch)**：

   - CPU 检测到 `int` 指令，查找**中断向量表 (IDT)**。
   - 发现 0x80 对应的是系统调用处理程序。
   - CPU 自动将特权级从 **Ring 3 切换到 Ring 0**。
   - CPU 跳转到内核中预定义的处理函数（`system_call`）。

4. **内核执行**：

   - 内核根据 `EAX` 中的编号，执行相应的内核函数（如 `sys_write`）。
   - 执行期间，内核拥有完全的硬件控制权。

5. **返回用户态**：
   - 内核执行完毕，将结果（或错误码）存入寄存器。
   - 执行 `iret` (Interrupt Return) 指令。
   - CPU 特权级从 **Ring 0 切回 Ring 3**，程序继续执行 `int 0x80` 之后的指令。

### 现代优化 (`syscall`)

虽然 `int 0x80` 是经典的软件中断方式，但它的开销较大（涉及复杂的中断处理流程）。现代 x86 CPU 提供了专门的指令 **`syscall`** (AMD64) 或 **`sysenter`** (Intel)，用于更快速地进行系统调用，绕过了部分传统中断的检查步骤，但其本质逻辑依然是：**用户态请求 -> 切换特权级 -> 内核态执行 -> 返回**。
