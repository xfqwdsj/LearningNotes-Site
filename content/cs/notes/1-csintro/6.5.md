---
title: 6.5 进程
---

## 什么是进程 (Process)？

在操作系统中，**进程**是正在运行的程序的实例。

- **程序 (Program)**：是静态的，存储在磁盘上的可执行文件（如 `chrome.exe`），是一组指令的集合。
- **进程 (Process)**：是动态的，是程序的一次执行过程。它不仅包含代码，还包含当前的活动状态（如程序计数器、寄存器值、变量值、堆栈等）。

**类比**：

- **程序**就像是菜谱（静态的文字）。
- **进程**就像是正在照着菜谱做菜的过程（动态的活动）。

## 进程的内存布局 (Process Memory Layout)

当程序被加载到内存中运行时，操作系统会为其分配独立的地址空间。一个典型的进程在内存中包含以下区域（从低地址到高地址）：

1. **代码段 (Text/Code Segment)**：
   - 存放 CPU 执行的机器指令。
   - 通常是**只读**的，且在多个进程间可**共享**（如运行多个 Chrome 标签页时，共享同一份代码）。
2. **数据段 (Data Segment)**：
   - 存放**已初始化**的全局变量和静态变量。
3. **BSS 段**：
   - 存放**未初始化**的全局变量和静态变量。
   - 在程序开始执行前，内核会将这段内存清零。
4. **堆 (Heap)**：
   - 用于**动态内存分配**（如 `malloc`, `new`）。
   - 向高地址生长。
5. **栈 (Stack)**：
   - 用于函数调用（存放局部变量、参数、返回地址）。
   - 向低地址生长。

## 进程的状态 (Process States)

一个进程在生命周期中会处于不同的状态。通用的五状态模型如下：

1. **新建 (New)**：进程正在被创建。操作系统为其分配 PCB（进程控制块），但尚未加载到内存。
2. **就绪 (Ready)**：进程已获得除 CPU 以外的所有资源，准备好运行，只等待 CPU 时间片。
   - _位置_：通常在“就绪队列”中排队。
3. **运行 (Running)**：进程正在 CPU 上执行指令。
   - _注意_：在单核 CPU 上，同一时刻只有一个进程处于运行状态。
4. **阻塞/等待 (Blocked/Waiting)**：进程暂停运行，等待某个事件发生（如等待 I/O 完成、等待键盘输入）。
   - 此时即使给它 CPU，它也无法运行。
5. **终止 (Terminated)**：进程执行完毕或被强制结束，操作系统回收其资源。

### 状态转换图

- **Ready $\to$ Running**：调度器选择了该进程（Dispatch）。
- **Running $\to$ Ready**：时间片用完（Timer Interrupt）或被高优先级进程抢占。
- **Running $\to$ Blocked**：进程请求 I/O 或等待事件（System Call）。
- **Blocked $\to$ Ready**：I/O 完成或事件发生（Interrupt）。
- **Running $\to$ Terminated**：进程退出（Exit）。

## 进程的核心数据结构

操作系统在内核空间维护了一系列数据结构来管理进程。

### 进程控制块 (Process Control Block, PCB)

PCB 是进程存在的唯一标志，操作系统用它来描述进程的基本情况和活动过程。PCB 中主要包含：

- **进程标识符 (PID)**：唯一标识进程的数字。
- **进程状态**：当前是 Ready, Running 还是 Blocked。
- **上下文数据**：
  - **程序计数器 (PC)**：下一条要执行的指令地址。
  - **CPU 寄存器**：累加器、栈指针、通用寄存器等（切换进程时需保存）。
- **记账信息**：CPU 使用时间、优先级等。

### 页表 (Page Table)

每个进程都有独立的虚拟地址空间。**页表**记录了该进程的**虚拟页面**与物理内存中**页帧**的映射关系。

- 它是实现内存隔离的关键，确保进程 A 无法访问进程 B 的内存。
- PCB 中通常包含指向该进程页表基地址的指针。

### 已打开文件表 (Open File Table)

进程在运行过程中会打开文件、网络套接字等资源。

- 操作系统为每个进程维护一张**文件描述符表**（File Descriptor Table）。
- 记录了文件读写指针的位置、访问权限等信息。

## 上下文切换 (Context Switch)

当 CPU 从一个进程切换到另一个进程时，需要保存当前进程的状态并恢复另一个进程的状态。这个过程叫**上下文切换**。

1. 保存当前进程 A 的上下文（PC, 寄存器等）到 A 的 PCB 中。
2. 更新 A 的 PCB 状态（如改为 Ready 或 Blocked）。
3. 选择另一个进程 B。
4. 更新 B 的 PCB 状态（改为 Running）。
5. 从 B 的 PCB 中恢复上下文（将值装入寄存器）。
6. CPU 开始执行 B。

**开销**：上下文切换是纯粹的开销（Overhead），因为切换期间 CPU 不做任何有效计算。

## 进程调度 (Process Scheduling)

操作系统的**调度器 (Scheduler)** 决定哪个就绪进程获得 CPU。

### 调度队列

- **作业队列**：系统中所有进程。
- **就绪队列**：内存中准备好运行的进程。
- **设备队列**：等待特定 I/O 设备的进程。

### 常见调度算法

#### 先来先服务 (First-Come, First-Served, FCFS)

这是最简单的调度算法，采用非抢占式策略。就像超市排队结账一样，CPU 按照进程请求的顺序进行分配。一旦进程获得 CPU，它就会一直运行直到完成或发生 I/O 阻塞。

##### FCFS 的优点

- **简单易行**：算法容易理解和实现。
- **公平性**：对于到达时间相同的进程，处理是公平的。

##### FCFS 的缺点

- **护航效应 (Convoy Effect)**：如果有一个长进程在运行，后面许多短进程必须等待，导致平均等待时间变长，CPU 和 I/O 设备利用率降低。
- **不适合分时系统**：无法保证响应时间。

#### 短作业优先 (Shortest Job First, SJF)

该算法优先调度**下一个 CPU 执行周期 (CPU Burst)** 最短的进程。它可以是抢占式的（最短剩余时间优先），也可以是非抢占式的。

##### SJF 的优点

- **最优平均等待时间**：在所有进程同时到达的情况下，SJF 能提供最小的平均等待时间。

##### SJF 的缺点

- **难以预测**：很难准确知道下一个 CPU 执行周期有多长，通常需要根据历史数据进行指数平均预测。
- **饥饿现象 (Starvation)**：如果系统中不断有短进程到来，长进程可能永远得不到执行。

#### 轮转调度 (Round Robin, RR)

这是专门为分时系统设计的算法。系统定义一个**时间片 (Time Quantum)**（通常为 10-100ms）。就绪队列被视为一个循环队列，CPU 轮流为每个进程服务一个时间片。

##### RR 的优点

- **响应时间快**：每个进程都能在一定时间内获得 CPU，适合交互式系统。
- **公平**：没有进程会连续占用 CPU 太久。

##### RR 的缺点

- **上下文切换开销**：如果时间片太短，频繁切换会浪费大量 CPU 时间。
- **退化为 FCFS**：如果时间片太长，算法就退化成了 FCFS。

#### 优先级调度 (Priority Scheduling)

系统为每个进程分配一个优先级，CPU 总是分配给优先级最高的进程。优先级可以是静态的（创建时确定）或动态的（运行时调整）。

##### 优先级调度的优点

- **灵活性**：可以根据重要性、紧迫性等因素灵活调度。

##### 优先级调度的缺点

- **饥饿现象**：低优先级的进程可能无限期等待。
- **解决方法**：**老化 (Aging)** 技术，即随着等待时间的增加，逐渐提高进程的优先级。
